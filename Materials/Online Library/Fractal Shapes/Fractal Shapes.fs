/*{
    "CREDIT": "Fractal Colours",
    "DESCRIPTION": "A Fractal algorithm mapped whose output can be mapped across 4 user specified colours. Generated by ChatGPT.",
    "TAGS": "color pixelmapping",
    "VSN": "0.9",
    "INPUTS": [ 
		{"LABEL": "Speed", "NAME": "mat_speed", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 }, 
		{"LABEL": "Scale", "NAME": "u_var1", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 }, 
		{"LABEL": "Offset", "NAME": "u_var2", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 },
		{"LABEL": "Time Mult", "NAME": "u_var6", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 },
		{"LABEL": "Non Linear", "NAME": "u_nonLinearTime", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 },
		{"LABEL": "Rand Factor", "NAME": "u_randomFactor", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 },
		{"LABEL": "Red Shift", "NAME": "u_var3", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 }, 
		{"LABEL": "Green Shift", "NAME": "u_var4", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 }, 
		{"LABEL": "Blue Shit", "NAME": "u_var5", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 },
		{"LABEL": "Map to Colors", "NAME": "mat_mapToPalette", "TYPE": "bool", "DEFAULT": false },
		{"LABEL": "No of Colours", "NAME": "u_paletteSize", "TYPE": "int", "MIN": 2, "MAX": 4, "DEFAULT": 2 },
		{"LABEL": "Colour Balance", "NAME": "mat_balance", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.5 },  
		{"LABEL": "Colour 1", "NAME": "u_paletteColor1", "TYPE": "color", "DEFAULT": [1.0,0.0,0.0,1.0] },
		{"LABEL": "Colour 2", "NAME": "u_paletteColor2", "TYPE": "color", "DEFAULT": [0.0,1.0,0.0,1.0] },
		{"LABEL": "Colour 3", "NAME": "u_paletteColor3", "TYPE": "color", "DEFAULT": [0.0,0.0,1.0,1.0] },
		{"LABEL": "Colour 4", "NAME": "u_paletteColor4", "TYPE": "color", "DEFAULT": [1.0,0.0,1.0,1.0] },
    ],
	"GENERATORS": [
        {"NAME": "mat_time", "TYPE": "time_base", "PARAMS": {"speed": "mat_speed"} },
    ],
}*/

// Function to compute a fractal shape
float fractal(vec2 p, float time, float var1, float var2) {
    float scale = 2.0 + var1;
    float offset = var2;
    float result = 0.0;
    for (int i = 0; i < 6; i++) {
        p = abs(p) / dot(p, p) - offset;
        result += sin(p.x * scale + time) + cos(p.y * scale + time);
    }
    return result;
}

// Function to map a value to a palette
vec4 mapToPalette(float value, vec4 color1, vec4 color2, vec4 color3, vec4 color4, int paletteSize, float balance) {
    float adjustedValue = value;
    if (paletteSize == 2) {
        adjustedValue = mix(value, 0.5, balance);
        return mix(color1, color2, adjustedValue);
    } else if (paletteSize == 3) {
        if (value < 0.5) {
            adjustedValue = mix(value * 2.0, 0.5, balance);
            return mix(color1, color2, adjustedValue);
        } else {
            adjustedValue = mix((value - 0.5) * 2.0, 0.5, balance);
            return mix(color2, color3, adjustedValue);
        }
    } else if (paletteSize == 4) {
        if (value < 0.33) {
            adjustedValue = mix(value * 3.0, 0.5, balance);
            return mix(color1, color2, adjustedValue);
        } else if (value < 0.66) {
            adjustedValue = mix((value - 0.33) * 3.0, 0.5, balance);
            return mix(color2, color3, adjustedValue);
        } else {
            adjustedValue = mix((value - 0.66) * 3.0, 0.5, balance);
            return mix(color3, color4, adjustedValue);
        }
    }
    return color1; // Fallback
}

vec4 materialColorForPixel( vec2 uv )
{
	// Time-based evolution with non-linear control
	float randomOffset = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453) * u_randomFactor;
    float time = mat_time * u_var6;
    time = time + u_nonLinearTime * sin(time + randomOffset); // Non-linear time adjustment with randomness

    // Generate fractal shapes
    float fractalValue = fractal(uv, time, u_var1, u_var2);

	vec4 color;
	if(mat_mapToPalette) {
		// Normalize fractal value for palette mapping
    	float normalizedValue = fractalValue * 0.5 + 0.5;
    	normalizedValue = clamp(normalizedValue, 0.0, 1.0);

    	// Map the fractal value to a palette or fallback gradient
    	color = mapToPalette(normalizedValue, u_paletteColor1, u_paletteColor2, u_paletteColor3, u_paletteColor4, u_paletteSize, mat_balance);
	} else {
    	// Map the fractal value to a color gradient
    	color = vec4(
        	0.5 + 0.5 * cos(fractalValue + u_var3),
        	0.5 + 0.5 * sin(fractalValue + u_var4),
        	0.5 + 0.5 * cos(fractalValue + u_var5),
			1.0
    	);
	}

    // Output the final color
	return color;
}