/*{
    "RESOURCE_TYPE": "Laser Material for MadMapper",
    "CREDIT": "Adapted by Cornelius // ProjectileObjects // Based on VDMX VIDVOX NYE ISF Shader and tutorial by David Lublin (https://vdmx.vidvox.net/tutorials/how-to-do-a-new-years-eve-countdown) comments generated by ChatGPT",
    "DESCRIPTION": "A laser shader that displays a clock (Time-of-day, Countdown) or Counter using DATE / TIME, with 7-segment lines. The Counter starts at 00:00:00.",
    "TAGS": "time, clock, laser, segment",
    "VSN": "1.3",
    "INPUTS": [
        {
            "NAME" : "colorInput",
            "TYPE" : "color",
            "DEFAULT" : [0.45, 1.0, 0.0, 1.0],
            "LABEL" : "Color"
        },
        {
            "VALUES" : [0,1,2],
            "NAME" : "clockMode",
            "TYPE" : "long",
            "DEFAULT" : 0,
            "LABEL" : "Clock Mode",
            "LABELS" : ["Time","Countdown","Application Counter"]
        },
        {
            "NAME" : "yOffset",
            "TYPE" : "float",
            "MAX" : 1,
            "DEFAULT" : 0,
            "MIN" : -1,
            "LABEL" : "Y Offset"
        },
        {
            "NAME" : "blinkingColons",
            "TYPE" : "bool",
            "DEFAULT" : true,
            "LABEL" : "Blink"
        },
        {
            "NAME" : "twentyFourHourStyle",
            "TYPE" : "bool",
            "DEFAULT" : false,
            "LABEL" : "24 Hour"
        },
        {
            "NAME" : "design_scale",
            "TYPE" : "float",
            "MIN": 0.0,
            "MAX": 2.0,
            "DEFAULT": 0.279,
            "LABEL": "Scale"
        },
        {
            "NAME": "global_x",
            "TYPE": "float",
            "MIN": -1.0,
            "MAX": 1.0,
            "DEFAULT": 0.0,
            "LABEL": "Position X"
        },
        {
            "NAME": "global_y",
            "TYPE": "float",
            "MIN": -1.0,
            "MAX": 1.0,
            "DEFAULT": 0.0,
            "LABEL": "Position Y"
        }
    ]
}*/

////////////////////////////////////////////////////////////
// In MadMapper and other ISF hosts, two important uniforms are 
// automatically provided (we do not need to declare them as 'uniform'):
//   1) DATE = vec4(year, month, day, secondsSinceMidnight)  
//             => DATE.a is the current local time in seconds since midnight.
//   2) TIME = float, representing the number of seconds since this shader was loaded.
//
// We define three clock modes via "clockMode":
//   0 => Time: uses DATE.a (current local time of day).
//   1 => Countdown: uses 86400 - DATE.a (time left until midnight).
//   2 => Application Counter: uses floor(TIME), effectively counting how long 
//       the application (or shader) has been running, starting at 0. 
//       We clamp fractional leftover so it always starts at 00:00:00.
//
// Additionally:
//   - If "blinkingColons" is true, colons blink off for the second half of each second.
//   - "twentyFourHourStyle" toggles between 24-hour display or 12-hour display (for mode=0).
//   - The display is drawn using a "7-segment line" approach for each digit, plus 2 colons.
//
// This is a laser-friendly approach that draws lines instead of pixels, 
// so each digit is constructed from multiple small line segments. 
////////////////////////////////////////////////////////////

const float PI = 3.14159265359;

// A structure representing a single line segment (start -> end).
// Each "segment" in a 7-segment digit uses this structure.
struct SegmentLine {
    vec2 startPt;
    vec2 endPt;
};

// We define the 7 segments for a single digit (A..G).
// Coordinates are around the origin (0,0), 
// and we shift them later for each digit or position.
SegmentLine[7] segments = SegmentLine[](
    // A (top horizontal)
    SegmentLine(vec2(-0.3,  0.5), vec2( 0.3,  0.5)),
    // B (upper right vertical)
    SegmentLine(vec2( 0.3,  0.5), vec2( 0.3,  0.0)),
    // C (lower right vertical)
    SegmentLine(vec2( 0.3,  0.0), vec2( 0.3, -0.5)),
    // D (bottom horizontal)
    SegmentLine(vec2(-0.3, -0.5), vec2( 0.3, -0.5)),
    // E (lower left vertical)
    SegmentLine(vec2(-0.3,  0.0), vec2(-0.3, -0.5)),
    // F (upper left vertical)
    SegmentLine(vec2(-0.3,  0.5), vec2(-0.3,  0.0)),
    // G (middle horizontal)
    SegmentLine(vec2(-0.3,  0.0), vec2( 0.3,  0.0))
);

////////////////////////////////////////////////////////////
// A function that maps each digit (0..9) to which of its
// 7 segments are ON or OFF. 
// A "true" entry means that segment is drawn for that digit.
////////////////////////////////////////////////////////////
bool[7] DIGIT_MAP(int d) {
    // "blank" means no segments lit (for invalid digits).
    bool[7] blank = bool[7](false,false,false,false,false,false,false);
    bool[7] zero  = bool[7](true, true,  true,  true,  true,  true,  false);
    bool[7] one   = bool[7](false,true,  true,  false, false, false, false);
    bool[7] two   = bool[7](true, true,  false, true,  true,  false, true);
    bool[7] three =bool[7](true, true,  true,  true,  false, false, true);
    bool[7] four  =bool[7](false,true,  true,  false, false, true,  true);
    bool[7] five  =bool[7](true, false, true,  true,  false, true,  true);
    bool[7] six   =bool[7](true, false, true,  true,  true,  true,  true);
    bool[7] seven =bool[7](true, true,  true,  false, false, false, false);
    bool[7] eight =bool[7](true, true,  true,  true,  true,  true,  true);
    bool[7] nine  =bool[7](true, true,  true,  true,  false, true,  true);

    // If digit out of 0..9, return blank (no segments).
    if(d<0||d>9) return blank;

    // Return the appropriate segment configuration.
    if(d==0) return zero;
    if(d==1) return one;
    if(d==2) return two;
    if(d==3) return three;
    if(d==4) return four;
    if(d==5) return five;
    if(d==6) return six;
    if(d==7) return seven;
    if(d==8) return eight;
    if(d==9) return nine;

    // Fallback (should never hit here).
    return blank;
}

////////////////////////////////////////////////////////////
// Main function: This is called for each point in the laser path.
// We compute the final position (pos) and color for each point.
// shapeNumber can be used to group lines into separate shapes if needed.
////////////////////////////////////////////////////////////
void laserMaterialFunc(int pointNumber, int pointCount, out vec2 pos, out vec4 color, out int shapeNumber, out vec4 userData)
{
    // 1) Retrieve the system time-of-day in seconds from DATE.a,
    //    and the app's "time since load" from TIME.
    float daySecs = DATE.a;  // local time-of-day in seconds
    float runSecs = TIME;    // seconds since this shader was loaded

    float baseSec = 0.0;

    // 2) Depending on clockMode, compute baseSec:
    if(clockMode==2) {
        // "Application Counter"
        // We take floor(TIME) so that it always starts at 00:00:00
        // ignoring fractional leftover from load time.
        baseSec = floor(runSecs);
    }
    else if(clockMode==1) {
        // "Countdown": from 86400 (24 hrs) down to 0
        // subtract daySecs from 86400.
        baseSec = 86400.0 - daySecs;
        // If negative, clamp to 0 (in case daySecs > 86400).
        if(baseSec<0.0) baseSec=0.0;
    }
    else {
        // "Time": normal local time-of-day, modded by 86400 for safety.
        baseSec = mod(daySecs,86400.0);
    }

    // 3) Extract hours/minutes/seconds from baseSec
    float tmpVal = floor(baseSec); // integer portion
    float s = mod(tmpVal,60.0);    // seconds
    tmpVal = floor(tmpVal/60.0);
    float m = mod(tmpVal,60.0);    // minutes
    tmpVal = floor(tmpVal/60.0);
    float h = mod(tmpVal,60.0);    // hours (0..24 or 12 hr logic below)

    // 4) 12-hour logic if "twentyFourHourStyle" is false and clockMode=0 (Time)
    if(!twentyFourHourStyle && clockMode==0){
        float hh = mod(h,12.0);
        if(hh<1.0) hh=12.0;
        h=hh;
    }

    // 5) Build the array of 6 digits => HH:MM:SS
    //    Each digit is split into "tens" and "ones".
    int Ht=int(floor(h/10.0));   // hour tens
    int Ho=int(mod(h,10.0));     // hour ones
    int Mt=int(floor(m/10.0));   // minute tens
    int Mo=int(mod(m,10.0));     // minute ones
    int St=int(floor(s/10.0));   // second tens
    int So=int(mod(s,10.0));     // second ones

    int digits[6]=int[](Ht,Ho, Mt,Mo, St,So);

    // 6) We have 6 digits, each with up to 7 segments => total 42 lines,
    //    plus 2 colons (each colon has 2 lines => 4 lines),
    //    for a total of 46 lines => 92 points. We'll check if pointNumber is beyond that.
    int digitSegCount = 6*7;      // 42
    int colonLineCount = 4;       // 2 colons => 4 lines total
    int lineCount = digitSegCount + colonLineCount; // 46 total lines
    int totalPoints = lineCount*2; // 92 total points

    // If the pointNumber is beyond 92, we skip rendering.
    if(pointNumber>=totalPoints){
        pos=vec2(0); 
        color=vec4(0); 
        shapeNumber=0; 
        return;
    }

    // Each line has 2 points: start & end. We'll figure out which line the current point is on:
    int lineIndex = pointNumber/2;
    bool isStart  = (pointNumber%2 == 0);

    // 7) Blinking colons: if "blinkingColons" is true, we skip drawing colons 
    //    when the fractional part of baseSec >= 0.5, i.e. for half the second.
    bool showColons = true;
    float fracSec = fract(baseSec);
    if(blinkingColons){
        if(fracSec>=0.5) showColons=false;
    }

    // 8) Distinguish between digit lines (0..41) and colon lines (42..45)
    if(lineIndex < digitSegCount){
        // We are in the digit segment region
        // figure out which digit and which segment
        int dIndex = lineIndex / 7;      // which digit
        int segIndex = lineIndex % 7;    // which of the 7 segments
        if(dIndex>5){
            // no valid digit => skip
            pos=vec2(0);
            color=vec4(0);
            shapeNumber=0;
            return;
        }

        // Check if this digit's segment is "ON" or not
        bool[7] segMap = DIGIT_MAP(digits[dIndex]);
        if(!segMap[segIndex]){
            // segment is OFF => skip
            pos=vec2(0);
            color=vec4(0);
            shapeNumber=0;
            return;
        }

        // get the line from the "segments" array
        vec2 linePos = (isStart? segments[segIndex].startPt : segments[segIndex].endPt);

        // horizontally offset each digit by 1.0 => total 6 digits => shift ~2.5 so they're centered
        float xOff = float(dIndex)*1.0 - 2.5;
        linePos.x += xOff;

        // apply user-specified scale, plus yOffset shift
        float adjOff = yOffset*1.2;
        linePos *= design_scale;
        linePos.y -= adjOff;
        linePos += vec2(global_x, global_y);

        // output position & color
        pos = linePos;
        color = colorInput;
        shapeNumber = lineIndex;
    }
    else {
        // we are in the colon lines region => lineIndex - digitSegCount => 0..3
        int cIndex = lineIndex - digitSegCount;
        if(cIndex>=4){
            // skip if beyond the colon lines
            pos=vec2(0);
            color=vec4(0);
            shapeNumber=0;
            return;
        }

        // if colons are "off" due to blinking logic, skip
        if(!showColons){
            pos=vec2(0);
            color=vec4(0);
            shapeNumber=0;
            return;
        }

        // We have 2 colons => colon0 (between hour & minute) => x= -1.0
        //                  => colon1 (between minute & second) => x= +1.0
        // Each colon has 2 lines => top dot & bottom dot
        int colonID = cIndex / 2;    // 0 or 1 => which colon
        bool top    = ( (cIndex % 2) == 0 );
        float xC    = (colonID==0)? -1.0 : +1.0;
        float yC    = top? 0.2 : -0.2;

        // transform colon's dot by scale, offset, position
        vec2 cPos = vec2(xC, yC) * design_scale;
        cPos.y -= (yOffset*1.2);
        cPos   += vec2(global_x, global_y);

        pos   = cPos;
        color = colorInput;
        shapeNumber = lineIndex;
    }
}